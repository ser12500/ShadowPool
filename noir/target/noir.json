{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"13038624675671790239","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hashes","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"token_addresses","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"amounts","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"nullifiers","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"secrets","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_proofs","type":{"kind":"array","length":3,"type":{"kind":"array","length":20,"type":{"kind":"field"}}},"visibility":"private"},{"name":"is_even_arrays","type":{"kind":"array","length":3,"type":{"kind":"array","length":20,"type":{"kind":"boolean"}}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"pdjRTuM4GIbhe+kxB/m/z3biuZXVChUoo0pVQR0YaYXm3jcBvy2slIpNjmzo5CV18tSZvm0ednevP2/3x8enX5sff71t7k77w2H/8/bwdL992T8dx9++/bnZ8OPty2m3G3+1+fT6eNTz9rQ7vmx+HF8Ph5vN7+3h9f0f/XreHt/Hl+1pfLW72eyOD+M4Bh/3h900+3NzObqbPzQicjs6QsM5kP9Hwd25kLpFhaRzoSwrlEuh15JC16dzoda5Qp4vuGcZktP5eH09vswfL4dbQFaZK/TXVmEovAd1dUnB5hzCWXOFOl+ohUDty4Ljo0vnu6kb6pJ17DuupPro5wqh1cswXa9V6/DNQPWiZTgvpPo8e0PGlUT0tWcZhph/F/3aZehX3w9X30a9XM2aZs/i2oeDo7vcD2Xuw0Gx8tNBWn1by6tva6WV1/PaOqQo53XwsnX41n2tfvV9rWH1bXn1LNbflqk7n0SKumTXc++VhXzZN3NdtHfnet67S7fsHFTPhZg9B1/bvBNPQc75EojvB3puKVctCWRxJfInWf8NDCs/YVxXP4CkbvUTyNWz+J7vpNW+09rt+1rgmx8QV9/G+g+IovNClPT14f7v8aft/f705T8km9JNF/FmU6KNmv74OLqNafz705jbWNrYj1d1fC9lGN/TeJeX+jH2XRujjWqj25jamNtY2ti3sfX61htab2i9ofWG1htab2i9ofWG1htab2i92nq19Wrr1darrVdbr7Zebb3aerX1ouuYBBMxMZPEJDMpTHomAxPKQTkoB+WgHJSDclAOykE5KIuyKIuyKIuyKIuyKIuyKJuyKZuyKZuyKZuyKZuyKSfKiXKinCgnyolyopwoJ8qJcqacKWfKmXKmnClnyplyppwpF8qFcqFcKBfKhXKhXCiDLN6VjcKjb2xjcjY5jV5M/CE0JmoT0cBagC3QFnALvAXgAnEBucBcgC5QF7AL3AXwAnkBvcBegC/QF/AL/AUAA4EBwcCgMCgMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAwKHY6sdWJvU5sdmK3E9ud3g3206R8yNVkcAKryeDHpH7I1WRwkisMCoPCoDAoDAqDwqAwKAwKg8KgMCgMCoPCoDAoDAqDwqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag8agMWgMGoPGoDFoDBqDxqAxaAwag2YfNPug2QfNPmj2QbMP+t3g9PXL7+1pv7077NoX+Y+vx/tP3+u//PPMK3zz/3x6ut89vJ520yP3+2vjQ/i/","file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"use std::hash::poseidon2;\nmod merkle_tree;\n\n/// Multi-currency anonymous deposit circuit\n/// Supports multiple deposits of different tokens (ETH and ERC20) in a single transaction\n/// Each deposit has its own commitment, nullifier, and secret\nfn main(\n    // Public inputs\n    root: pub Field,\n    nullifier_hashes: pub [Field; 3], // Array of nullifier hashes for each deposit\n    recipient: pub Field,\n    token_addresses: pub [Field; 3], // Array of token addresses (0 for ETH, ERC20 address for tokens)\n    amounts: pub [Field; 3], // Array of amounts for each deposit\n    // Private inputs\n    nullifiers: [Field; 3], // Array of nullifiers for each deposit\n    secrets: [Field; 3], // Array of secrets for each deposit\n    merkle_proofs: [[Field; 20]; 3], // Array of merkle proofs for each commitment\n    is_even_arrays: [[bool; 20]; 3], // Array of even flags for each merkle proof\n) {\n    // Process each deposit\n    for i in 0..3 {\n        // Compute commitment for this deposit: Poseidon2(nullifier, secret, token_address, amount)\n        let commitment: Field = poseidon2::Poseidon2::hash(\n            [nullifiers[i], secrets[i], token_addresses[i], amounts[i]],\n            4,\n        );\n\n        // Check that the nullifier matches the nullifier hash\n        let computed_nullifier_hash: Field = poseidon2::Poseidon2::hash([nullifiers[i]], 1);\n        assert(computed_nullifier_hash == nullifier_hashes[i]);\n\n        // Check that the commitment is in the Merkle tree\n        let computed_root: Field =\n            merkle_tree::compute_merkle_root(commitment, merkle_proofs[i], is_even_arrays[i]);\n        assert(computed_root == root);\n    }\n}\n","path":"/home/sergey/ShadowPool/noir/src/main.nr"},"51":{"source":"use std::hash::poseidon2;\n\npub fn compute_merkle_root(\n    leaf: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n) -> Field {\n    // temporary variable to store the hash for the current level we are working on\n    let mut hash: Field = leaf;\n    // increment through the levels\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], hash)\n        };\n        // compute the hash for the current level\n        hash = poseidon2::Poseidon2::\n        hash([left, right], 2);\n    }\n    // return the root of the Merkle tree\n    hash\n}","path":"/home/sergey/ShadowPool/noir/src/merkle_tree.nr"}},"names":["main"],"brillig_names":[]}